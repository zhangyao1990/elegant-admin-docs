---
title: 构建工具
date: 2023-07-18 08:54:17
permalink: /pages/93353b/
article: false
---
## 什么是构建工具？

### 一般项目会具备的一些功能

* typescript：如果遇到 ts 文件我们需要使用 tsc 将其转化为 js文件
* React/Vue：安装 react-compile / vue-compile 将 jsx 或者 vue 文件转化为render函数然后解析为js文件
* less/sass/postcss：安装对应的 loader 将其编译为 css 文件
* 语法降级：使用 babel 将高等语法降级，兼容更多浏览器
* 体积优化：在打包的时候使用压缩工具压缩代码，例如uglifyjs
* .......

在我们将代码稍微改动一些的话，上述流程就会变得很麻烦，例如，改动了App.tsx

App.tsx --> tsc --> App.jsx --> react-compile --> App.js

如果有一个工具将上述流程全部集成到一起，帮我们完成上述流程，我们只需要去书写代码就好了，这个就是构建工具做的事。

### 构建工具到底做了些什么事情
1、模块化开发支持：多种模块化支持，支持直接从 node_modules 里面引入代码

2、处理代码兼容性：比如 babel 语法降级，less，ts语法转化，当然这些不是构建工具完成的，构建工具是把处理这些内容的工具集成起来了，然后进行了自动化处理

3、提高项目性能：压缩文件，代码分割

4、优化开发体验：
* 构建工具会自动监听文件的变化，当文件变化以后会自动调用其对应的工具处理，然后进行重新打包，然后浏览器再重新运行，这个过程也就是我们经常听说的热更新--hot replacement
* 开发服务器：跨域的问题，可以通过代码配置解决跨域问题

### 常见的构建工具
市面上流行的构建工具：

* webpack
* vite
* esbuild
* gulp
* rollup
*.......
  
### 总结
  构建工具可以让我们不用每次都去关心代码是如何在浏览器运行的，我们只需要给他一个配置文件（当然不给的话也会有一些默认的配置），有了这个集成的配置后，在下次文件代码更新后，调用一次对应的处理工具就好了，结合热更新，我们就不用去管这些了，这就让我们在写代码的过程中怎么爽就怎么写就好了。

## Vite相较于webpack的优势

:::tip 下面是 vite 官网的一段话
然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。
:::

起因：我们的项目越来越大 ---> 构建工具 ( webpack ) 需要处理的 js 代码越来越多，这跟 webpack 的构建过程有关。

结果：构建工具需要很长的时间才能启动开发服务器 ( 也就是将项目运行起来需要很多时间 )
## webpack构建原理

webpack支持多种模块化支持，因为有可能项目不止跑在浏览器端
```js
// 这一段代码最终会到浏览器里去运行
const lodash = require("lodash"); // commonjs 规范
import Vue from "vue"; // es6 module

// webpack是允许我们这么写的

```
webpack编译原理：利用 AST 抽象语法分析工具 分析出写的 js 文件有哪些导入和导出的操作，构建工具是运行在服务端的，所以他可以对文件进行操作。webpack会将上述代码转化成以下形式

```js
// webpack的一个转换结果
const lodash = webpack_require("lodash");
const Vue = webpack_require("vue");
```
转化过程大致是以下的流程 ( 简易 )
```js
;(function (modules) {
    function webpack_require() {}
    // 入口是index.js
    // 通过webpack的配置文件得来的: webpack.config.js ./src/index.js
    modules[entry](webpack_require)
})({
    './src/index.js': webpack_require => {
        const lodash = webpack_require('lodash')
        const Vue = webpack_require('vue')
    }
})
```
因为webpack支持多种模块化，他一开始需要统一模块化代码，所以意味着他需要将所有的依赖文件全部读一遍

### webpack与vite的区别

<img src="/img/png/webpack.png" style="margin-bottom: 10px;margin-top:10px;" width = "100%" height = "auto" alt="图片名称" align=center />

<img src="/img/png/vite.png" width = "100%" height = "auto" alt="图片名称" align=center />

* 可以从[vite](https://cn.vitejs.dev/)官网两种图看出来，webpack是找到入口文件后，会读取所有的模块然后打包，最后启动成功。而vite因为是基于es modules的，所以他不需要统一模块化代码，在找到入口文件后会直接加载当前入口对应的模块，然后再使用到其他模块的时候动态加载，这样就节省了很大时间。

* 那么竟然vite有这么大的优势，webpack会被vite淘汰吗？，因为两者侧重点不一样，webpack的兼容性更好，支持多种模块化，而vite是不允许写commjs规范模块的，vite关注浏览器端的开发体验。

* vite上手难度更低，webpack有很多配置项，loader，plugin等。
